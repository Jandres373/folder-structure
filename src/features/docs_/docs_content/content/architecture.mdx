# Arquitectura del Proyecto

<div className="flex items-center gap-2 p-4 bg-primary/5 rounded-lg border border-primary/20 mb-8">
  <span role="img" aria-label="building" className="text-2xl">ğŸ—ï¸</span>
  <p className="text-sm text-zinc-700">
    Este documento describe la arquitectura del proyecto, basada en Screaming Architecture y organizada por features.
  </p>
</div>

## VisiÃ³n General

La arquitectura del proyecto sigue un enfoque modular y escalable, organizado en capas jerÃ¡rquicas que van desde las rutas hasta los componentes individuales:

```bash
src/
â”œâ”€â”€ routes/           # DefiniciÃ³n de rutas y URLs
â”œâ”€â”€ pages/            # Componentes de pÃ¡gina
â”œâ”€â”€ features/         # Funcionalidades modulares
â”œâ”€â”€ shared/           # Componentes y utilidades compartidas
â””â”€â”€ utils/            # Utilidades generales
```

## Screaming Architecture

<div className="p-4 bg-blue-50 rounded-lg border border-blue-200 mb-6">
  <h3 className="font-semibold mb-2 text-blue-900">ğŸ’¡ Â¿QuÃ© es Screaming Architecture?</h3>
  <p className="text-sm text-blue-800">
    Es un patrÃ³n arquitectÃ³nico donde la estructura de carpetas "grita" el propÃ³sito de la aplicaciÃ³n. Cada feature debe nombrarse de manera que explique claramente su funciÃ³n.
  </p>
</div>

## JerarquÃ­a de Componentes

1. **Rutas (URLs)**
   - Nivel mÃ¡s alto de la aplicaciÃ³n
   - Definen los puntos de entrada
   - Gestionadas por TanStack Router

2. **PÃ¡ginas**
   - Componentes que corresponden a rutas
   - Controlan el layout y disposiciÃ³n de features
   - ActÃºan como orquestadores de features

3. **Features**
   - Agrupaciones funcionales de componentes
   - Encapsulan una funcionalidad especÃ­fica
   - Mantienen su propia estructura interna

4. **Componentes**
   - Unidades mÃ¡s pequeÃ±as y reutilizables
   - Forman parte de las features
   - Mantienen responsabilidad Ãºnica

## Estructura de Features

Cada feature sigue una estructura interna predefinida:

```bash
feature_name/
â”œâ”€â”€ api/              # Queries y mutaciones de TanStack Query
â”œâ”€â”€ components/       # Componentes React especÃ­ficos
â”œâ”€â”€ hooks/           # Hooks personalizados
â”œâ”€â”€ state/           # Estado global (Zustand)
â”œâ”€â”€ services/        # Funciones de conexiÃ³n con el servidor
â”œâ”€â”€ types/           # Tipos TypeScript
â”œâ”€â”€ content/         # Contenido (MDX, JSON, etc.)
â””â”€â”€ styles/          # Estilos especÃ­ficos
```

### DescripciÃ³n de Carpetas

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 my-6">
  <div className="p-4 rounded-lg border border-border bg-card">
    <h4 className="font-semibold mb-2">ğŸ“¡ api/</h4>
    <p className="text-sm text-muted-foreground">
      Contiene queries y mutaciones de TanStack Query para manejo de datos remotos.
    </p>
  </div>
  <div className="p-4 rounded-lg border border-border bg-card">
    <h4 className="font-semibold mb-2">ğŸ§© components/</h4>
    <p className="text-sm text-muted-foreground">
      Componentes React especÃ­ficos de la feature.
    </p>
  </div>
  <div className="p-4 rounded-lg border border-border bg-card">
    <h4 className="font-semibold mb-2">ğŸ£ hooks/</h4>
    <p className="text-sm text-muted-foreground">
      Hooks personalizados para lÃ³gica reutilizable.
    </p>
  </div>
  <div className="p-4 rounded-lg border border-border bg-card">
    <h4 className="font-semibold mb-2">ğŸ’¾ state/</h4>
    <p className="text-sm text-muted-foreground">
      GestiÃ³n de estado global usando Zustand.
    </p>
  </div>
  <div className="p-4 rounded-lg border border-border bg-card">
    <h4 className="font-semibold mb-2">ğŸ”Œ services/</h4>
    <p className="text-sm text-muted-foreground">
      Funciones para comunicaciÃ³n con el servidor.
    </p>
  </div>
  <div className="p-4 rounded-lg border border-border bg-card">
    <h4 className="font-semibold mb-2">ğŸ“ types/</h4>
    <p className="text-sm text-muted-foreground">
      Definiciones de tipos TypeScript.
    </p>
  </div>
  <div className="p-4 rounded-lg border border-border bg-card">
    <h4 className="font-semibold mb-2">ğŸ“š content/</h4>
    <p className="text-sm text-muted-foreground">
      Contenido estÃ¡tico en MDX, JSON o TS.
    </p>
  </div>
  <div className="p-4 rounded-lg border border-border bg-card">
    <h4 className="font-semibold mb-2">ğŸ¨ styles/</h4>
    <p className="text-sm text-muted-foreground">
      Estilos especÃ­ficos de la feature.
    </p>
  </div>
</div>

## Ejemplo de Feature

Tomemos como ejemplo la feature de documentaciÃ³n (`docs_`):

```typescript
// Estructura tÃ­pica de una feature
docs_/
â”œâ”€â”€ api/
â”‚   â””â”€â”€ queries.ts
â”‚   â””â”€â”€ migrations.ts
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ DocSidebarFeat.tsx
â”‚   â””â”€â”€ DocContentFeat.tsx
â”œâ”€â”€ hooks/
â”‚   â””â”€â”€ useDocNavigation.ts
â”œâ”€â”€ state/
â”‚   â””â”€â”€ docsStore.ts
â”œâ”€â”€ content/
â”‚   â””â”€â”€ docs/
â”‚       â”œâ”€â”€ introduction.mdx
â”‚       â””â”€â”€ architecture.mdx
â””â”€â”€ types/
    â””â”€â”€ documentation.ts
```

## Beneficios de esta Arquitectura

1. **Modularidad**
   - Cada feature es independiente y autocontenida
   - Facilita el mantenimiento y testing
   - Permite el desarrollo paralelo

2. **Escalabilidad**
   - FÃ¡cil agregar nuevas features
   - Estructura consistente y predecible
   - Clara separaciÃ³n de responsabilidades

3. **ReutilizaciÃ³n**
   - Componentes compartidos en `shared/`
   - Hooks y utilidades reutilizables
   - Patrones consistentes

4. **Mantenibilidad**
   - CÃ³digo organizado y predecible
   - FÃ¡cil localizaciÃ³n de funcionalidades
   - Clara separaciÃ³n de concerns

## Mejores PrÃ¡cticas

1. **Nombrado de Features**
   - Usar nombres descriptivos que indiquen la funcionalidad
   - Seguir un formato consistente
   - Evitar nombres genÃ©ricos

2. **OrganizaciÃ³n de Carpetas**
   - Crear solo las carpetas necesarias
   - Mantener una estructura plana cuando sea posible
   - Seguir el principio de responsabilidad Ãºnica

3. **GestiÃ³n de Estado**
   - Usar Zustand para estado global
   - TanStack Query para estado del servidor
   - Estado local (useState) para componentes simples

4. **Componentes Compartidos**
   - Extraer componentes comunes a `shared/components` y otros tipos de recursos comunes a `shared/[tipo_de_recurso]`
   - Mantener componentes especÃ­ficos en features
   - Documentar componentes reutilizables
